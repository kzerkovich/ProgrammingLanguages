;;В функции используются 2 обязательных параметра и 2 дополнительных
;;l - обязательный параметр -исходный список
;;n - обязательный параметр - номер уровня 
;;cur-depth-num - дополнительный параметр - номер текущего уровня
;;new-l - дополнительный параметр - итоговый список
(defun f18 (l n &optional (cur-depth-num 1) new-l)
  (if (null l) (reverse new-l) ; Если список l пустой, то возвращаем 
                               ;"отзеркаленный" конечный список
      (let ((el (car l)))      ; В противном случае обозначим через переменную
                               ; el первый элемент списка l
        (cond
          ((listp el)              ; Если этот элемент - список,
           (if (= cur-depth-num n) ; то проверяем, совпадают ли текущий уровень
                                   ; и уровень, который давался на вход
               (f18 (cdr l) n cur-depth-num new-l) ; Если уровни совпадают, то 
                                                  ; мы игнорируем этот элемент и
                                                  ; вызываем рекурсивно функцию 
                                                  ; от хвоста исходного списка
               (f18 (cdr l)
                    n 
                    cur-depth-num 
                    (cons (f18 el n (+ cur-depth-num 1)) new-l))))
              ; Если же уровни не совпадают, то мы рекурсивно вызываем функцию,
              ; где последним элементом будет результат вызова функции от 
              ; элемента el и номером текущего уровня увеличенным на 1
          (T (f18 (cdr l) n cur-depth-num (cons el new-l)))))))
          ; Если элемент el списном не является, то мы его присоединяем к 
          ; итоговому списку

(print (f18 '(c a (a ((b) a a (b)) a)
              (a d (a a) (b a a (b a a (b) a z) a h a a (b) a) a)) 2))