(defmacro repeat ((&body body) condition)
  ;; генерируем два вспомогательных идентификатора. Один сохраняем
  ;; в переменной func-name, второй - в переменной counter. 
  ;; Первый идентификатор будем использовать как имя нашей рекурсивной 
  ;; функции для цикла, а второй - как счетчик итераций.
  (let ((func-name (gensym))
        (counter (gensym)))
    ;; определяем тело самой макроподстановки с указанными параметрами.
    ;; Заменяем вызов макроса на определение локальной функции
    ;; (с помощью labels) с дальнейшим вызовом этой функции.
    `(labels ((,func-name (,counter)
                ;; Вычисляем все выражения, входящие в body.
                (progn ,@body)
                ;; После это проверяем условие: если оно NIl, то рекурсивно 
                ;; вызываем функции со значением счетчика, увеличенным на 1.
                ;; В противном случае выдаем счетчик.
                (if ,condition
                    ,counter
                    (,func-name (1+ ,counter)))))
       (,func-name 1)))) ; начальный вызов функции с счетчиком равным 1.

;; Основная функция.
(defun f5 (x n)
  ;; Определяем начальные параметры:
  ;; i - счетчик,
  ;; accum - аккумулятор, в который заноситься результат,
  ;; x-deg - переменная, равная квадрату x,
  ;; frac - очередной элемент суммы,
  ;; cnt - счетчик для знаменателя дроби.
  (let ((i 0)
        (accum 0.0d0)
        (x-deg (* x x))
        (frac x)
        (cnt 3.0d0))
    ;; Если счетчик меньше введенного зачения n, то запускаем repeat.
    (if (<= i n)
        (repeat
          ;; В теле увеличиваем i на 1,
          ;; к аккумулятору прибавляем очередной элемент суммы,
          ;; считаем следующий элемент суммы,
          ;; увеличиваем счетчик знаменателя на 2.
          ((incf i)
           (setq accum (+ accum frac))
           (setq frac (/ (/ (* frac x-deg) 
                            cnt) 
                         (- cnt 1.0d0)))
           (setq cnt (+ cnt 2.0d0)))
          (> i n))) ; условие окончания цикла.
    accum)) ; Результат работы функции - значение в accum, его и выдаем.

;; Примеры работы счетчика.
(print (let ((i 0)) (repeat ((incf i)) (> i 5)))) ; *6*
(print (let ((counter 2) (i 0)) (repeat ((incf i counter)) (> i 5)))) ; *3*

;; Примеры работы основной функции.
;; Значения при тех же входных данных в 5 задании:
;; Для y1 - 0.304520293447,
;; Для y2 - 1.02651672571,
;; Для y3 - 2.9421742881.
(fresh-line)
(princ "(f5 0.3d0 100)")
(defparameter *y1* (f5 0.3d0 100))
(print *y1*)
(fresh-line)
(princ "(f5 0.9d0 100)")
(defparameter *y2* (f5 0.9d0 100))
(print *y2*)
(fresh-line)
(princ "(f5 1.8d0 100)")
(defparameter *y3* (f5 1.8d0 100))
(print *y3*)